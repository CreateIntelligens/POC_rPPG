<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{{ title }}</title>
    <link rel="stylesheet" href="/static/style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ©º</text></svg>">
</head>
<body>
    <header class="hero">
        <h1>ğŸ©º {{ title }}</h1>
        <p>æ”¯æ´å½±ç‰‡ä¸Šå‚³èˆ‡ç¶²è·¯æ”å½±æ©Ÿåˆ†æï¼Œåˆ©ç”¨ VitalLens API ä¼°ç®—å¿ƒç‡ã€å‘¼å¸ç‡èˆ‡ç›¸é—œæ³¢å½¢ã€‚</p>
        <p class="api-status">{{ api_key_status }}</p>
    </header>

    <main class="container">
        <div class="analysis-tabs">
            <button type="button" class="analysis-tab active" data-mode-tab="upload">ğŸ¬ å½±ç‰‡ä¸Šå‚³</button>
            <button type="button" class="analysis-tab" data-mode-tab="record">ğŸ“¹ éŒ„å½±åˆ†æ</button>
            <button type="button" class="analysis-tab" data-mode-tab="realtime">âš¡ å³æ™‚ä¸²æµ</button>
        </div>
        <section class="panel" id="video-upload">
            <h2>ğŸ“ å½±ç‰‡æª”æ¡ˆåˆ†æ</h2>
            <form id="file-form" enctype="multipart/form-data">

                <!-- é€²éšæ‹–æ‹½ä¸Šå‚³å€åŸŸ -->
                <div id="drop-zone" class="drop-zone enhanced">
                    <div class="drop-zone-content">
                        <div class="drop-icon">ğŸ¬</div>
                        <p class="drop-text">æ‹–æ‹½å½±ç‰‡æª”æ¡ˆåˆ°æ­¤è™•</p>
                        <p class="drop-subtext">æˆ–é»æ“Šé¸æ“‡æª”æ¡ˆ</p>
                        <div class="upload-button-container">
                            <button type="button" class="drop-button" onclick="document.getElementById('video-input').click()">
                                <span class="button-icon">ğŸ“</span> é¸æ“‡æª”æ¡ˆ
                            </button>
                        </div>
                        <p class="drop-hint">æ”¯æ´ MP4, AVI, MOV, MKV, WebM æ ¼å¼ï¼Œæœ€å¤§ 100MB</p>
                        <div class="format-icons">
                            <span class="format-tag">MP4</span>
                            <span class="format-tag">AVI</span>
                            <span class="format-tag">MOV</span>
                            <span class="format-tag">WebM</span>
                        </div>
                    </div>
                    <div id="file-preview" class="file-preview" style="display: none;">
                        <div class="file-info">
                            <div class="file-thumbnail">ğŸ¥</div>
                            <div class="file-details">
                                <span class="file-name"></span>
                                <span class="file-size"></span>
                                <div class="file-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: 0%"></div>
                                    </div>
                                    <span class="progress-text">æº–å‚™ä¸­...</span>
                                </div>
                            </div>
                            <button type="button" class="remove-file" onclick="clearFileSelection()">
                                <span>âœ•</span>
                            </button>
                        </div>
                    </div>
                    <div id="upload-progress" class="upload-progress" style="display: none;">
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-fill"></div>
                            </div>
                            <span class="progress-percentage">0%</span>
                        </div>
                    </div>
                </div>

                <input id="video-input" name="video" type="file" accept="video/*" required style="display: none;">

                <label for="file-method">é¸æ“‡æª¢æ¸¬æ–¹æ³•</label>
                <select id="file-method" name="method" required>
                    {% for option in methods %}
                    <option value="{{ option }}" {% if option == default_method %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>


                <div id="file-api-key-section" class="form-field hidden">
                    <label for="file-api-key">API Keyï¼ˆä½¿ç”¨ VITALLENS æ™‚å¿…å¡«ï¼‰</label>
                    <input id="file-api-key" name="api_key" type="password" placeholder="è«‹è¼¸å…¥ VitalLens API Key">
                </div>

                <button type="submit">ğŸ” é–‹å§‹åˆ†æ</button>
            </form>
            <div class="status" id="file-status">ç­‰å¾…ä¸Šå‚³å½±ç‰‡...</div>
            <div id="file-results" class="results-grid" aria-live="polite"></div>
            <img id="file-plot" class="plot" alt="å½±ç‰‡åˆ†æåœ–è¡¨" style="display: none;">
        </section>

        <section class="panel hidden" id="webcam-analysis">
            <h2>ğŸ“¹ ç¶²è·¯æ”å½±æ©Ÿåˆ†æ</h2>
            <form id="webcam-form" method="post" action="#">
                <div class="form-field mode-record-only">
                    <label for="webcam-method">éŒ„å½±æª¢æ¸¬æ–¹æ³•</label>
                    <select id="webcam-method" name="method" required>
                        <optgroup label="å‰ç«¯åˆ†æ (å³æ™‚)">
                            <option value="js-pos">å‰ç«¯å¿«é€Ÿ (POS)</option>
                            <option value="js-chrom">å‰ç«¯å¿«é€Ÿ (CHROM)</option>
                            <option value="js-vitallens">å‰ç«¯ç²¾ç¢º (VitalLens)</option>
                        </optgroup>
                        <optgroup label="å¾Œç«¯åˆ†æ (ç²¾ç¢º)">
                            {% for option in methods %}
                            <option value="{{ option }}" {% if option == default_method %}selected{% endif %}>{{ option }}</option>
                            {% endfor %}
                        </optgroup>
                    </select>
                </div>
                <div class="form-field mode-realtime-only hidden">
                    <label for="realtime-method">å³æ™‚æª¢æ¸¬æ–¹æ³•</label>
                    <select id="realtime-method" name="realtime_method">
                        <option value="js-pos" selected>å‰ç«¯å¿«é€Ÿ (POS)</option>
                        <option value="js-chrom">å‰ç«¯å¿«é€Ÿ (CHROM)</option>
                        <option value="js-vitallens">å‰ç«¯ç²¾ç¢º (VitalLens)</option>
                    </select>
                </div>
                <div id="webcam-api-key-section" class="form-field hidden">
                    <label for="webcam-api-key">API Keyï¼ˆä½¿ç”¨ VITALLENS æ™‚å¿…å¡«ï¼‰</label>
                    <input id="webcam-api-key" name="api_key" type="password" placeholder="è«‹è¼¸å…¥ VitalLens API Key">
                </div>
                <div class="form-field mode-record-only">
                <label for="recording-duration">éŒ„å½±æ™‚é–“ï¼ˆç§’ï¼‰</label>
                <input id="recording-duration" name="duration" type="number" min="5" max="45" value="15" step="5">
                </div>
                <div class="button-row mode-record-only">
                    <button type="button" id="start-recording">ğŸ”´ é–‹å§‹éŒ„å½±</button>
                    <button type="button" id="stop-recording" class="secondary" disabled>â¹ï¸ åœæ­¢éŒ„å½±</button>
                </div>
                <div class="button-row mode-realtime-only hidden">
                    <button type="button" id="start-realtime">âš¡ é–‹å§‹å³æ™‚</button>
                    <button type="button" id="stop-realtime" class="secondary" disabled>â¹ï¸ åœæ­¢å³æ™‚</button>
                </div>
            </form>
            <div class="status hidden" id="webcam-status">æº–å‚™é–‹å§‹éŒ„å½±...</div>
            <div class="video-container">
                <video id="webcam-preview" class="webcam-preview" autoplay muted playsinline></video>
                <div class="face-detection-info mode-realtime-only hidden" id="face-detection-info">
                    <div class="detection-indicator">
                        <span class="indicator-light"></span>
                        <span class="indicator-text">å°šæœªå•Ÿå‹•</span>
                    </div>
                    <div class="heart-rate-preview" id="heart-rate-preview">
                        <span class="hr-label">å³æ™‚å¿ƒç‡:</span>
                        <span class="hr-value" id="hr-value">-- BPM</span>
                        <span class="hr-confidence" id="hr-confidence"></span>
                    </div>
                </div>
            </div>
            <div id="record-results" class="mode-record-only">
                <div id="webcam-results" class="results-grid" aria-live="polite"></div>
                <img id="webcam-plot" class="plot" alt="ç¶²è·¯æ”å½±æ©Ÿåˆ†æåœ–è¡¨" style="display: none;">
                <pre id="webcam-result" class="result"></pre>
            </div>
        </section>

        <section class="panel info">
            <h2>ğŸ“‹ ä½¿ç”¨èªªæ˜</h2>
            <h3>ğŸ¬ å½±ç‰‡ä¸Šå‚³</h3>
            <ol>
                <li>æ‹–æ‹½æˆ–é¸æ“‡å½±ç‰‡æª”æ¡ˆä¸Šå‚³ï¼ˆå»ºè­° 5-30 ç§’ï¼Œè‡‰éƒ¨æ¸…æ™°å¯è¦‹ï¼‰</li>
                <li>é¸æ“‡åˆé©çš„æª¢æ¸¬æ–¹æ³•ï¼ˆä½¿ç”¨ VITALLENS éœ€è¦ API Keyï¼‰</li>
                <li>é»æ“Šã€Œé–‹å§‹åˆ†æã€ï¼Œç¨ç­‰ç‰‡åˆ»å³å¯æŸ¥çœ‹å¿ƒç‡åˆ†æçµæœ</li>
            </ol>
            <h3>ğŸ“¹ éŒ„å½±åˆ†æ</h3>
            <ol>
                <li>å…è¨±ç€è¦½å™¨å­˜å–æ”å½±æ©Ÿï¼Œç¢ºä¿ç•«é¢é¡¯ç¤ºæ­£å¸¸</li>
                <li>èª¿æ•´éŒ„å½±æ™‚é–“ï¼ˆ5-60 ç§’ï¼‰ï¼Œä¿æŒè‡‰éƒ¨æ­£å°é¡é ­</li>
                <li>é»æ“Šã€Œé–‹å§‹éŒ„å½±ã€ï¼Œå®Œæˆå¾Œè‡ªå‹•é€²è¡Œåˆ†æä¸¦é¡¯ç¤ºçµæœ</li>
            </ol>
            <h3>âš¡ å³æ™‚ä¸²æµ</h3>
            <ol>
                <li>é–‹å•Ÿæ”å½±æ©Ÿæ¬Šé™ï¼Œç¢ºä¿è‡‰éƒ¨åœ¨ç•«é¢ä¸­å¤®</li>
                <li>é¸æ“‡å³æ™‚æª¢æ¸¬æ–¹æ³•ï¼Œé»æ“Šã€Œé–‹å§‹å³æ™‚ã€</li>
                <li>ä¿æŒç©©å®šå§¿å‹¢ï¼Œå³å¯çœ‹åˆ°å³æ™‚å¿ƒç‡æ•¸æ“šæ›´æ–°</li>
            </ol>
            <p>âš ï¸ æœ¬å·¥å…·åƒ…ä¾›å¥åº·åƒè€ƒï¼Œæ•¸å€¼ä¸å¯ç”¨æ–¼é†«ç™‚è¨ºæ–·ã€‚å¦‚æœ‰å¥åº·ç–‘æ…®è«‹è«®è©¢å°ˆæ¥­é†«å¸«ã€‚</p>
        </section>
    </main>

    <footer>
        <div class="disclaimer">
            <p><strong>âš ï¸ é‡è¦æé†’:</strong> æœ¬ç³»çµ±æä¾›çš„æ•¸å€¼åƒ…ç‚ºä¼°ç®—å€¼ï¼Œæ‡‰æ ¹æ“šæä¾›çš„ä¿¡å¿ƒåº¦ï¼ˆ0-1ï¼‰é€²è¡Œè§£è®€ã€‚VitalLens API ä¸¦éé†«ç™‚è¨­å‚™ï¼Œå…¶ä¼°ç®—çµæœä¸é©ç”¨æ–¼ä»»ä½•é†«ç™‚ç”¨é€”ã€‚</p>
        </div>
        <small>Â© {{ title }} | æ”¯æ´å…è²»èˆ‡ VITALLENS API æ–¹æ³•</small>
    </footer>

    <script>
        // DOM å…ƒç´ 
        const fileForm = document.getElementById('file-form');
        const fileStatus = document.getElementById('file-status');
        const fileResults = document.getElementById('file-results');
        const dropZone = document.getElementById('drop-zone');
        const videoInput = document.getElementById('video-input');
        const filePreview = document.getElementById('file-preview');
        const uploadProgress = document.getElementById('upload-progress');
        let uploadProgressTimer = null;

        const webcamForm = document.getElementById('webcam-form');
        const startRecordingBtn = document.getElementById('start-recording');
        const stopRecordingBtn = document.getElementById('stop-recording');
        const webcamStatus = document.getElementById('webcam-status');
        const webcamResults = document.getElementById('webcam-results');
        const webcamPreview = document.getElementById('webcam-preview');
        const faceDetectionInfo = document.getElementById('face-detection-info');
        const hrValue = document.getElementById('hr-value');
        const webcamApiInput = document.getElementById('webcam-api-key');
        const indicatorText = faceDetectionInfo?.querySelector('.indicator-text');
        const indicatorLight = faceDetectionInfo?.querySelector('.indicator-light');
        const webcamApiSection = document.getElementById('webcam-api-key-section');
        const webcamMethodSelect = document.getElementById('webcam-method');
        const realtimeMethodSelect = document.getElementById('realtime-method');
        const modeTabs = Array.from(document.querySelectorAll('[data-mode-tab]'));
        const videoUploadSection = document.getElementById('video-upload');
        const webcamPanel = document.getElementById('webcam-analysis');
        const recordSections = Array.from(document.querySelectorAll('.mode-record-only'));
        const realtimeSections = Array.from(document.querySelectorAll('.mode-realtime-only'));
        const recordResultsWrapper = document.getElementById('record-results');
        const startRealtimeBtn = document.getElementById('start-realtime');
        const stopRealtimeBtn = document.getElementById('stop-realtime');
        const webcamPlot = document.getElementById('webcam-plot');
        const webcamResult = document.getElementById('webcam-result');

        const MAX_FILE_SIZE_MB = 50;
        const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
        const MAX_UPLOAD_DURATION_SECONDS = 45;

        let mediaStream = null;
        let selectedFile = null;
        let dragCounter = 0;
        let statusPoller = null;
        let statusSocket = null;
        let isRecordingActive = false;
        let isRealtimeActive = false;
        const MODE_UPLOAD = 'upload';
        const MODE_RECORD = 'record';
        const MODE_REALTIME = 'realtime';
        const VITALLENS_CDN_URL = 'https://unpkg.com/vitallens@0.2.0/dist/vitallens.browser.js';
        const API_KEY_STORAGE_KEY = 'vitallens_api_key';
        let vitalLensConstructorPromise = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let vitalLensJS = null;
        let vitalLensVitalsHandler = null;
        let realtimeStatusTimer = null;
        let hasRealtimeResult = false;
        let currentMode = MODE_UPLOAD;

        // åˆå§‹åŒ–æ‹–æ‹½ä¸Šå‚³åŠŸèƒ½
        function initializeDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            dropZone.addEventListener('drop', handleDrop, false);
            videoInput.addEventListener('change', handleFileSelect, false);

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function highlight(e) {
                if (e.type === 'dragenter') {
                    dragCounter++;
                }
                dropZone.classList.add('drag-over');
            }

            function unhighlight(e) {
                if (e.type === 'dragleave') {
                    dragCounter--;
                    if (dragCounter === 0) {
                        dropZone.classList.remove('drag-over');
                    }
                } else if (e.type === 'drop') {
                    dragCounter = 0;
                    dropZone.classList.remove('drag-over');
                }
            }

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFiles(files);
            }

            function handleFileSelect(e) {
                const files = e.target.files;
                handleFiles(files);
            }

            function handleFiles(files) {
                if (files.length > 0) {
                    const file = files[0];
                    if (validateFile(file)) {
                        selectedFile = file;
                        showFilePreview(file);
                    }
                }
            }

            function validateFile(file) {
                const allowedTypes = ['video/mp4', 'video/avi', 'video/mov', 'video/quicktime', 'video/mkv', 'video/webm'];
                if (!allowedTypes.includes(file.type) && !file.name.match(/\.(mp4|avi|mov|mkv|webm)$/i)) {
                    alert('ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼ã€‚è«‹é¸æ“‡ MP4, AVI, MOV, MKV æˆ– WebM æ ¼å¼çš„å½±ç‰‡ã€‚');
                    return false;
                }

                const maxSize = 100 * 1024 * 1024;
                if (file.size > maxSize) {
                    alert('æª”æ¡ˆéå¤§ã€‚è«‹é¸æ“‡å°æ–¼ 100MB çš„å½±ç‰‡æª”æ¡ˆã€‚');
                    return false;
                }

                return true;
            }

            function showFilePreview(file) {
                const fileName = filePreview.querySelector('.file-name');
                const fileSize = filePreview.querySelector('.file-size');
                const progressText = filePreview.querySelector('.progress-text');
                const progressFill = filePreview.querySelector('.progress-fill');

                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                progressText.textContent = 'æº–å‚™ä¸­...';
                progressFill.style.width = '0%';

                filePreview.style.display = 'block';

                let progress = 0;
                const interval = setInterval(() => {
                    progress += Math.random() * 30;
                    if (progress >= 100) {
                        progress = 100;
                        progressText.textContent = 'æº–å‚™å®Œæˆ';
                        clearInterval(interval);
                    } else {
                        progressText.textContent = `æª¢æŸ¥ä¸­... ${Math.round(progress)}%`;
                    }
                    progressFill.style.width = progress + '%';
                }, 200);
            }

            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        if (webcamForm) {
            webcamForm.addEventListener('submit', (event) => {
                event.preventDefault();
            });
        }

        if (webcamApiInput) {
            const savedKey = loadSavedApiKey();
            if (savedKey) {
                webcamApiInput.value = savedKey;
            }

            const persistHandler = (event) => {
                persistApiKey(event.target.value);
            };

            webcamApiInput.addEventListener('change', persistHandler);
            webcamApiInput.addEventListener('blur', persistHandler);
        }

        function updateWebcamStatus(message) {
            if (webcamStatus) {
                webcamStatus.textContent = message;
            }
        }

        function clearWebcamResults() {
            if (webcamResult) {
                webcamResult.textContent = '';
            }
            if (webcamPlot) {
                webcamPlot.style.display = 'none';
                webcamPlot.removeAttribute('src');
            }
        }

        async function ensureWebcamPreview() {
            if (mediaStream || isRecordingActive) {
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateWebcamStatus('ç€è¦½å™¨ä¸æ”¯æ´æ”å½±æ©ŸåŠŸèƒ½ï¼Œè«‹ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„ Chromeã€Edge æˆ– Firefoxã€‚');
                throw new Error('MediaDevices API not available');
            }

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: false
                });
                webcamPreview.srcObject = mediaStream;
                await webcamPreview.play();

                if (currentMode === MODE_REALTIME) {
                    resetRealtimeStatus();
                    updateWebcamStatus('å³æ™‚åˆ†æå°šæœªå•Ÿå‹•ï¼Œè«‹é»æ“Šé–‹å§‹ã€‚');
                    setRealtimeControlsState(false);
                } else {
                    updateWebcamStatus('æ”å½±æ©Ÿå·²å•Ÿå‹•ï¼Œæº–å‚™é–‹å§‹éŒ„å½±ã€‚');
                }
            } catch (error) {
                mediaStream = null;
                updateWebcamStatus('ç„¡æ³•å­˜å–æ”å½±æ©Ÿï¼Œè«‹ç¢ºèªè£ç½®å¯ç”¨ä¸¦æˆäºˆæ¬Šé™ã€‚');
                throw error;
            }
        }

        function releaseWebcamPreview() {
            stopRealtimeAnalysis();
            setRealtimeControlsState(false);
            if (faceDetectionInfo) {
                faceDetectionInfo.classList.add('hidden');
            }
            if (webcamPreview) {
                webcamPreview.pause();
                webcamPreview.srcObject = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach((track) => track.stop());
                mediaStream = null;
            }
        }

        async function resumeWebcamPreview() {
            if (!mediaStream && !isRecordingActive) {
                try {
                    await ensureWebcamPreview();
                } catch (error) {
                    console.warn('Unable to resume webcam preview', error);
                }
            }
        }

        // å·²è¨»è§£ï¼šå‡çš„å¿ƒç‡æ¨¡æ“¬åŠŸèƒ½
        // function startHeartRateSimulation() {
        //     if (heartRateSimulation) {
        //         return;
        //     }

        //     let bpm = 78 + Math.random() * 6;
        //     heartRateSimulation = setInterval(() => {
        //         bpm += (Math.random() - 0.5) * 4;
        //         bpm = Math.max(55, Math.min(110, bpm));
        //         hrValue.textContent = `${Math.round(bpm)} BPM`;
        //     }, 1500);
        // }

        // function stopHeartRateSimulation() {
        //     if (heartRateSimulation) {
        //         clearInterval(heartRateSimulation);
        //         heartRateSimulation = null;
        //     }
        //     hrValue.textContent = '-- BPM';
        // }

        async function loadVitalLensConstructor() {
            if (!vitalLensConstructorPromise) {
                vitalLensConstructorPromise = import(VITALLENS_CDN_URL)
                    .then((module) => {
                        const ctor = module?.VitalLens || module?.default;
                        if (!ctor) {
                            throw new Error('VitalLens constructor not found in module exports.');
                        }

                        // æš´éœ²æ–¼å…¨åŸŸä¾¿æ–¼åµéŒ¯ï¼Œä½†æ ¸å¿ƒä»ä½¿ç”¨æœ¬åœ°å¿«å–
                        window.VitalLens = ctor;
                        window.VitalLensModule = module;
                        return ctor;
                    })
                    .catch((error) => {
                        vitalLensConstructorPromise = null;
                        throw error;
                    });
            }

            return vitalLensConstructorPromise;
        }

        function clearRealtimeStatusMonitoring() {
            if (realtimeStatusTimer) {
                clearTimeout(realtimeStatusTimer);
                realtimeStatusTimer = null;
            }
        }

        function scheduleRealtimeStatusCheck() {
            clearRealtimeStatusMonitoring();
            hasRealtimeResult = false;
            realtimeStatusTimer = setTimeout(() => {
                if (hasRealtimeResult) {
                    return;
                }
                if (hrValue) {
                    hrValue.textContent = 'å°šæœªå–å¾—';
                }
                updateWebcamStatus('å°šæœªå–å¾—æœ‰æ•ˆè¨Šè™Ÿï¼Œè«‹ä¿æŒæ­£å°é¡é ­ä¸¦ç¢ºä¿å…‰ç·šå……è¶³ã€‚');
                if (indicatorText) {
                    indicatorText.textContent = 'ç­‰å¾…è¨Šè™Ÿ';
                }
                if (currentMode === MODE_REALTIME) {
                    setIndicatorState('waiting');
                }
            }, 6000);
        }

        function resetRealtimeStatus() {
            hasRealtimeResult = false;
            clearRealtimeStatusMonitoring();
            setIndicatorState(null);
            if (indicatorText) {
                indicatorText.textContent = 'å°šæœªå•Ÿå‹•';
            }
            if (hrValue) {
                hrValue.textContent = '-- BPM';
            }
            const hrConfidence = document.getElementById('hr-confidence');
            if (hrConfidence) {
                hrConfidence.textContent = '';
            }
        }

        function loadSavedApiKey() {
            try {
                const saved = localStorage.getItem(API_KEY_STORAGE_KEY);
                return (saved || '').trim();
            } catch (error) {
                console.warn('Unable to access localStorage for API key:', error);
                return '';
            }
        }

        function persistApiKey(value) {
            const trimmed = (value || '').trim();
            try {
                if (trimmed) {
                    localStorage.setItem(API_KEY_STORAGE_KEY, trimmed);
                } else {
                    localStorage.removeItem(API_KEY_STORAGE_KEY);
                }
            } catch (error) {
                console.warn('Unable to persist API key:', error);
            }

            if (webcamApiInput && webcamApiInput.value !== trimmed) {
                webcamApiInput.value = trimmed;
            }

            return trimmed;
        }

        function setIndicatorState(state) {
            if (!indicatorLight) {
                return;
            }

            indicatorLight.classList.remove('waiting', 'active');

            if (state === 'waiting') {
                indicatorLight.classList.add('waiting');
            } else if (state === 'active') {
                indicatorLight.classList.add('active');
            }
        }

        function toggleElements(elements, shouldShow) {
            elements.forEach((element) => {
                if (!element) {
                    return;
                }
                element.classList.toggle('hidden', !shouldShow);
            });
        }

        function setRealtimeControlsState(isActive) {
            isRealtimeActive = isActive;
            if (startRealtimeBtn) {
                startRealtimeBtn.disabled = isActive;
            }
            if (stopRealtimeBtn) {
                stopRealtimeBtn.disabled = !isActive;
            }
        }

        async function setAnalysisMode(mode) {
            if (!mode || mode === currentMode) {
                updateApiKeyVisibility();
                return;
            }

            if (currentMode === MODE_REALTIME && isRealtimeActive) {
                stopRealtimeAnalysis();
                setRealtimeControlsState(false);
            }

            if (currentMode === MODE_RECORD && isRecordingActive) {
                try {
                    await stopWebcamRecording();
                } catch (error) {
                    console.warn('åœæ­¢éŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }

            currentMode = mode;

            modeTabs.forEach((tab) => {
                tab.classList.toggle('active', tab.dataset.modeTab === mode);
            });

            if (mode === MODE_UPLOAD) {
                videoUploadSection?.classList.remove('hidden');
                webcamPanel?.classList.add('hidden');
                webcamStatus?.classList.add('hidden');
                updateWebcamStatus('');
                stopRealtimeAnalysis();
                clearStatusPolling();
                setRealtimeControlsState(false);
                setRecordingState(false);
            } else {
                videoUploadSection?.classList.add('hidden');
                webcamPanel?.classList.remove('hidden');
                toggleElements(recordSections, mode === MODE_RECORD);
                toggleElements(realtimeSections, mode === MODE_REALTIME);
                if (recordResultsWrapper) {
                    recordResultsWrapper.classList.toggle('hidden', mode !== MODE_RECORD);
                }
                if (webcamStatus) {
                    webcamStatus.classList.remove('hidden');
                }
                faceDetectionInfo?.classList.toggle('hidden', mode !== MODE_REALTIME);

                if (mode === MODE_RECORD) {
                    updateWebcamStatus('æº–å‚™é–‹å§‹éŒ„å½±...');
                    setRecordingState(false);
                    setRealtimeControlsState(false);
                } else if (mode === MODE_REALTIME) {
                    clearStatusPolling();
                    updateWebcamStatus('å³æ™‚åˆ†æå°šæœªå•Ÿå‹•ï¼Œè«‹é»æ“Šé–‹å§‹ã€‚');
                    resetRealtimeStatus();
                    setRealtimeControlsState(false);
                }
            }

            updateApiKeyVisibility();
        }

        async function handleStartRealtime() {
            if (isRealtimeActive) {
                return;
            }

            try {
                await ensureWebcamPreview();
            } catch (error) {
                console.error('Failed to initialise webcam preview', error);
                updateWebcamStatus(error.message || 'ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿé è¦½');
                return;
            }

            const methodValue = realtimeMethodSelect ? realtimeMethodSelect.value : 'js-pos';

            try {
                await startRealtimeAnalysis(methodValue);
                setRealtimeControlsState(true);
            } catch (error) {
                console.error('Unable to start realtime analysis', error);
                updateWebcamStatus(error.message || 'å³æ™‚åˆ†æå•Ÿå‹•å¤±æ•—');
                setRealtimeControlsState(false);
            }
        }

        function handleStopRealtime() {
            stopRealtimeAnalysis();
            setRealtimeControlsState(false);
            updateWebcamStatus('å³æ™‚åˆ†æå·²åœæ­¢ã€‚');
        }

        function updateApiKeyVisibility() {
            const recordNeedsKey = Boolean(webcamMethodSelect && webcamMethodSelect.value && webcamMethodSelect.value.toLowerCase().includes('vitallens'));
            const realtimeNeedsKey = Boolean(realtimeMethodSelect && realtimeMethodSelect.value && realtimeMethodSelect.value.toLowerCase().includes('vitallens'));
            const shouldShow = (currentMode === MODE_RECORD && recordNeedsKey) || (currentMode === MODE_REALTIME && realtimeNeedsKey);

            if (webcamApiSection) {
                webcamApiSection.classList.toggle('hidden', !shouldShow);
            }
        }

        function updateFileApiKeyVisibility() {
            const fileMethodSelect = document.getElementById('file-method');
            const fileApiSection = document.getElementById('file-api-key-section');

            if (!fileMethodSelect || !fileApiSection) {
                return;
            }

            const needsApiKey = fileMethodSelect.value && fileMethodSelect.value.toLowerCase().includes('vitallens');
            fileApiSection.classList.toggle('hidden', !needsApiKey);
        }

        // VitalLens.js å³æ™‚å¿ƒç‡æª¢æ¸¬åŠŸèƒ½
        async function initVitalLensJS(methodName = 'pos') {
            const normalizedMethod = (methodName || 'pos').toLowerCase();

            if (vitalLensJS && vitalLensJS.__method === normalizedMethod) {
                return vitalLensJS;
            }

            if (vitalLensJS) {
                try {
                    vitalLensJS.stopVideoStream?.();
                } catch (stopError) {
                    console.warn('åœæ­¢æ—¢æœ‰ VitalLens å¯¦ä¾‹æ™‚ç™¼ç”ŸéŒ¯èª¤:', stopError);
                }

                if (typeof vitalLensJS.removeEventListener === 'function' && vitalLensVitalsHandler) {
                    try {
                        vitalLensJS.removeEventListener('vitals', vitalLensVitalsHandler);
                    } catch (removeError) {
                        console.warn('ç§»é™¤ VitalLens äº‹ä»¶ç›£è½æ™‚ç™¼ç”ŸéŒ¯èª¤:', removeError);
                    }
                }

                try {
                    if (typeof vitalLensJS.close === 'function') {
                        await vitalLensJS.close();
                    }
                } catch (closeError) {
                    console.warn('é—œé–‰ VitalLens å¯¦ä¾‹æ™‚ç™¼ç”ŸéŒ¯èª¤:', closeError);
                }

                vitalLensJS = null;
                vitalLensVitalsHandler = null;
            }

            try {
                const VitalLensCtor = await loadVitalLensConstructor();
                const rawApiKey = webcamApiInput ? webcamApiInput.value : '';
                const apiKey = persistApiKey(rawApiKey);

                vitalLensJS = new VitalLensCtor({
                    method: normalizedMethod,
                    apiKey: apiKey || undefined,
                });
                vitalLensJS.__method = normalizedMethod;
                vitalLensJS.__vitalsListenerAttached = false;

                vitalLensVitalsHandler = (payload) => {
                    try {
                        const data = payload?.detail ?? payload;
                        const heart = data?.vital_signs?.heart_rate;
                        const bpmValue = heart?.value;
                        const confidence = heart?.confidence;

                        if (typeof bpmValue === 'number') {
                            updateHeartRateDisplay(bpmValue, confidence);
                        }
                    } catch (handlerError) {
                        console.error('VitalLens.js vitals handler error:', handlerError);
                    }
                };

                if (typeof vitalLensJS.addEventListener === 'function' && vitalLensVitalsHandler) {
                    vitalLensJS.addEventListener('vitals', vitalLensVitalsHandler);
                }

                console.log('VitalLens.js initialized successfully');
                return vitalLensJS;
            } catch (error) {
                console.error('Failed to initialize VitalLens.js:', error);
                vitalLensVitalsHandler = null;
                vitalLensJS = null;
                throw error;
            }
        }

        function updateHeartRateDisplay(heartRate, confidence) {
            if (hrValue) {
                if (typeof heartRate === 'number' && Number.isFinite(heartRate)) {
                    hrValue.textContent = `${heartRate.toFixed(1)} BPM`;
                    hasRealtimeResult = true;
                    if (currentMode === MODE_REALTIME) {
                        if (indicatorText) {
                            indicatorText.textContent = 'è¨Šè™Ÿç©©å®š';
                        }
                        clearRealtimeStatusMonitoring();
                        updateWebcamStatus(`å³æ™‚å¿ƒç‡ ${heartRate.toFixed(1)} BPM`);
                        setIndicatorState('active');
                    }
                } else {
                    hrValue.textContent = '-- BPM';
                    if (currentMode === MODE_REALTIME) {
                        setIndicatorState('waiting');
                    }
                }
            }

            const hrConfidence = document.getElementById('hr-confidence');
            if (!hrConfidence) {
                return;
            }

            if (typeof confidence === 'number' && Number.isFinite(confidence)) {
                const normalized = confidence > 1 ? confidence / 100 : confidence;
                const confidencePercent = Math.round(normalized * 100);
                hrConfidence.textContent = `(${confidencePercent}%)`;
                hrConfidence.style.color = normalized > 0.7
                    ? 'var(--success)'
                    : normalized > 0.5
                        ? 'var(--warning)'
                        : 'var(--danger)';
            } else {
                hrConfidence.textContent = '';
            }
        }

        // VitalLens.js æ¨¡æ“¬å¿ƒç‡å‡½æ•¸å·²ç§»é™¤

        async function startRealtimeAnalysis(methodValue) {
            const stream = webcamPreview?.srcObject;
            if (!stream) {
                throw new Error('æ”å½±æ©Ÿé è¦½å°šæœªå•Ÿå‹•');
            }

            try {
                const selectedMethod = (methodValue || 'js-pos').replace('js-', '') || 'pos';
                const instance = await initVitalLensJS(selectedMethod);
                await instance.setVideoStream(stream, webcamPreview);
                instance.startVideoStream();

                if (typeof instance.addEventListener === 'function' && !instance.__vitalsListenerAttached) {
                    instance.addEventListener('vitals', (event) => {
                        const payload = event?.detail ?? event;
                        const heart = payload?.vital_signs?.heart_rate;
                        updateHeartRateDisplay(heart?.value, heart?.confidence);
                    });
                    instance.__vitalsListenerAttached = true;
                }

                if (faceDetectionInfo) {
                    faceDetectionInfo.classList.remove('hidden');
                }

                if (indicatorText) {
                    indicatorText.textContent = 'ç­‰å¾…è¨Šè™Ÿ';
                }
                setIndicatorState('waiting');

                if (hrValue) {
                    hrValue.textContent = 'ç­‰å¾…è³‡æ–™...';
                }

                hasRealtimeResult = false;
                scheduleRealtimeStatusCheck();
                updateWebcamStatus('å³æ™‚åˆ†æå·²å•Ÿå‹•ï¼Œè«‹ä¿æŒç©©å®šã€‚');
            } catch (error) {
                console.error('Failed to start realtime analysis:', error);
                clearRealtimeStatusMonitoring();
                if (hrValue) {
                    hrValue.textContent = 'åˆ†æå¤±æ•—';
                }
                if (indicatorText) {
                    indicatorText.textContent = 'å°šæœªå•Ÿå‹•';
                }
                setIndicatorState(null);
                throw error;
            }
        }

        function stopRealtimeAnalysis() {
            if (vitalLensJS) {
                try {
                    vitalLensJS.stopVideoStream();
                } catch (error) {
                    console.warn('Failed to stop VitalLens stream:', error);
                }
            }

            resetRealtimeStatus();
            isRealtimeActive = false;

            if (faceDetectionInfo) {
                faceDetectionInfo.classList.add('hidden');
            }

            if (indicatorText) {
                indicatorText.textContent = 'å°šæœªå•Ÿå‹•';
            }

            if (hrValue) {
                hrValue.textContent = '-- BPM';
            }

            const hrConfidence = document.getElementById('hr-confidence');
            if (hrConfidence) {
                hrConfidence.textContent = '';
            }

            setRealtimeControlsState(false);
        }

        function setRecordingState(isRecording) {
            isRecordingActive = isRecording;
            startRecordingBtn.disabled = isRecording;
            stopRecordingBtn.disabled = !isRecording;

            // å·²è¨»è§£ï¼šå‡çš„å¿ƒç‡æ¨¡æ“¬åŠŸèƒ½
            // if (isRecording) {
            //     startHeartRateSimulation();
            // } else {
            //     stopHeartRateSimulation();
            // }
        }

        function scheduleStatusPolling() {
            clearStatusPolling();
            checkRecordingStatus();
            statusPoller = setInterval(checkRecordingStatus, 2000);
        }

        function clearStatusPolling() {
            if (statusPoller) {
                clearInterval(statusPoller);
                statusPoller = null;
            }
        }

        function clearWebcamResults() {
            if (webcamResults) {
                webcamResults.innerHTML = '';
            }
        }

        function displayWebcamResults(data) {
            if (!webcamResults) return;

            if (data.results && data.results.length > 0) {
                let resultsHtml = '';
                data.results.forEach(result => {
                    resultsHtml += formatResultItem(result);
                });
                webcamResults.innerHTML = resultsHtml;
            } else {
                webcamResults.innerHTML = '<p>æ²’æœ‰æª¢æ¸¬åˆ°çµæœ</p>';
            }
        }

        function formatResultItem(result) {
            const formattedText = result.result_text ? formatResultText(result.result_text) : '';

            return `
                <div class="result-item">
                    <h3>${result.display_name || 'Webcam Recording'}</h3>
                    ${formattedText}
                    ${result.plot_image ? `<img src="data:image/png;base64,${result.plot_image}" class="plot" alt="åˆ†æåœ–è¡¨">` : ''}
                </div>
            `;
        }

        function formatResultText(rawText) {
            if (!rawText) return '';

            const lines = rawText.split('\n').filter(line => line.trim());

            // è§£ææ•¸æ“š
            const data = {
                heartRate: null,
                heartRateConfidence: null,
                respiratoryRate: null,
                faceInfo: null,
                ppgWaveform: null,
                notes: [],
                otherInfo: []
            };

            lines.forEach((rawLine) => {
                const line = String(rawLine || '').trim();
                if (!line) {
                    return;
                }

                if (line.indexOf('Heart Rate:') === 0) {
                    const hrText = line.replace('Heart Rate: ', '').trim();
                    // è§£ææ•¸å€¼ä¸¦æ ¼å¼åŒ–ç‚ºä¸€ä½å°æ•¸
                    const match = hrText.match(/(\d+\.?\d*)/);
                    if (match) {
                        const value = parseFloat(match[1]);
                        if (!Number.isNaN(value)) {
                            const unit = hrText.replace(match[1], '').trim();
                            data.heartRate = `${value.toFixed(1)} ${unit}`;
                        } else {
                            data.heartRate = hrText;
                        }
                    } else {
                        data.heartRate = hrText;
                    }
                } else if (line.indexOf('HR Confidence:') === 0) {
                    const confidence = parseFloat(line.replace('HR Confidence: ', ''));
                    if (!Number.isNaN(confidence) && confidence < 1.0) {
                        data.heartRateConfidence = confidence;
                    }
                } else if (line.indexOf('Respiratory Rate:') === 0) {
                    const rrText = line.replace('Respiratory Rate: ', '').trim();
                    // è§£ææ•¸å€¼ä¸¦æ ¼å¼åŒ–ç‚ºä¸€ä½å°æ•¸
                    const match = rrText.match(/(\d+\.?\d*)/);
                    if (match) {
                        const value = parseFloat(match[1]);
                        if (!Number.isNaN(value)) {
                            const unit = rrText.replace(match[1], '').trim();
                            data.respiratoryRate = `${value.toFixed(1)} ${unit}`;
                        } else {
                            data.respiratoryRate = rrText;
                        }
                    } else {
                        data.respiratoryRate = rrText;
                    }
                } else if (line.indexOf('Face Confidence:') === 0) {
                    const potential = line.replace('Face Confidence: ', '').trim();
                    if (potential && potential.toLowerCase().indexOf('face detection coordinates') === -1) {
                        data.faceInfo = potential;
                    }
                } else if (line.indexOf('PPG Waveform:') === 0) {
                    data.ppgWaveform = line.replace('PPG Waveform: ', '');
                } else if (line.indexOf('Note:') === 0) {
                    const note = line.replace('Note: ', '');
                    if (!note.includes('not capable of providing a confidence estimate') && !note.includes('hence returning 1')) {
                        data.notes.push(note);
                    }
                } else if (line.includes(':') && line.indexOf('System Message:') !== 0) {
                    const [key, value] = line.split(':').map(s => s.trim());
                    if (value && !key.match(/^(Heart Rate|HR Confidence|Respiratory Rate|Face Confidence|PPG Waveform|Note)$/)) {
                        data.otherInfo.push({ key, value });
                    }
                }
            });

            let html = '';

            // ç”Ÿå‘½å¾µè±¡è¡¨æ ¼
            if (data.heartRate || data.respiratoryRate) {
                html += `
                    <div class="vital-signs-table">
                        <h4>ğŸ«€ ç”Ÿå‘½å¾µè±¡</h4>
                        <table class="vital-table">
                            <thead>
                                <tr>
                                    <th>é …ç›®</th>
                                    <th>æ•¸å€¼</th>
                                    <th>ä¿¡å¿ƒåº¦</th>
                                    <th>å‚™è¨»</th>
                                </tr>
                            </thead>
                            <tbody>`;

                if (data.heartRate) {
                    const confidenceText = data.heartRateConfidence
                        ? `${Math.round(data.heartRateConfidence * 100)}%`
                        : 'â€”';
                    const confidenceClass = data.heartRateConfidence
                        ? (data.heartRateConfidence > 0.8 ? 'high' : data.heartRateConfidence > 0.6 ? 'medium' : 'low')
                        : '';

                    html += `
                        <tr>
                            <td>â¤ï¸ å¿ƒç‡</td>
                            <td class="vital-value">${data.heartRate}</td>
                            <td class="confidence-${confidenceClass}">${confidenceText}</td>
                            <td>æ­£å¸¸ç¯„åœ 60-100 BPM</td>
                        </tr>`;
                }

                if (data.respiratoryRate) {
                    html += `
                        <tr>
                            <td>ğŸ« å‘¼å¸ç‡</td>
                            <td class="vital-value">${data.respiratoryRate}</td>
                            <td>â€”</td>
                            <td>æ­£å¸¸ç¯„åœ 12-20 RPM</td>
                        </tr>`;
                }

                html += `
                            </tbody>
                        </table>
                    </div>`;
            }

            // æ³¢å½¢æ‘˜è¦
            if (data.ppgWaveform) {
                html += `
                    <div class="ppg-summary">
                        <span class="ppg-label">ğŸ“ˆ PPG æ³¢å½¢è³‡æ–™</span>
                        <span class="ppg-value">${data.ppgWaveform}</span>
                    </div>`;
            }

            // è‡‰éƒ¨åˆ†æ
            if (data.faceInfo) {
                html += `
                    <div class="face-analysis">
                        <h4>ğŸ‘¤ è‡‰éƒ¨åˆ†æ</h4>
                        <p>${data.faceInfo}</p>
                    </div>`;
            }

            // é€²éšè³‡è¨Šï¼ˆæŠ˜ç–Šå€ï¼‰
            const hasAdvancedInfo = data.notes.length > 0 || data.otherInfo.length > 0;
            if (hasAdvancedInfo) {
                html += `
                    <div class="advanced-info">
                        <details>
                            <summary>ğŸ” é€²éšè³‡è¨Š</summary>
                            <div class="advanced-content">`;

                if (data.notes.length > 0) {
                    html += `
                        <div class="notes-section">
                            <h5>â„¹ï¸ åˆ†æèªªæ˜</h5>
                            ${data.notes.map(note => `<p class="note-item">${note}</p>`).join('')}
                        </div>`;
                }

                if (data.otherInfo.length > 0) {
                    html += `
                        <div class="other-info">
                            <h5>ğŸ“Š å…¶ä»–è³‡è¨Š</h5>
                            ${data.otherInfo.map(info => `<div class="info-row"><span class="info-key">${info.key}:</span> <span class="info-value">${info.value}</span></div>`).join('')}
                        </div>`;
                }

                html += `
                            </div>
                        </details>
                    </div>`;
            }

            return html ? `<div class="formatted-results">${html}</div>` : '';
        }

        async function processFrontendRecording(videoBlob, mimeType, method, apiKey) {
            const jsMethod = method.replace('js-', '');
            const normalizedKey = persistApiKey(apiKey);

            if (jsMethod.startsWith('vitallens') && !normalizedKey) {
                throw new Error('ä½¿ç”¨ VitalLens æ–¹æ³•æ™‚éœ€è¦æä¾› API Key');
            }

            updateWebcamStatus('éŒ„å½±å®Œæˆï¼Œæ­£åœ¨é€²è¡Œå‰ç«¯åˆ†æ...');

            const VitalLensCtor = await loadVitalLensConstructor();
            const analyzer = new VitalLensCtor({
                method: jsMethod,
                apiKey: normalizedKey || undefined,
            });

            try {
                const extension = mimeType.includes('mp4') ? 'mp4' : 'webm';
                const fileForProcessing = new File([videoBlob], `webcam-recording.${extension}`, {
                    type: mimeType,
                    lastModified: Date.now(),
                });

                const result = await analyzer.processVideoFile(fileForProcessing);
                renderFrontendResult(result, jsMethod);
                updateWebcamStatus('å‰ç«¯åˆ†æå®Œæˆï¼');
            } finally {
                if (typeof analyzer.close === 'function') {
                    try {
                        await analyzer.close();
                    } catch (closeError) {
                        console.warn('é—œé–‰ VitalLens åˆ†æå™¨æ™‚ç™¼ç”Ÿå•é¡Œ:', closeError);
                    }
                }
            }
        }

        function renderFrontendResult(result, method) {
            if (!webcamResults) {
                return;
            }

            const displayName = method.toUpperCase();
            const vitalSigns = result?.vital_signs || {};
            const heartRate = vitalSigns.heart_rate;
            const respiratoryRate = vitalSigns.respiratory_rate;
            const message = result?.message;

            const heartRateText = heartRate && typeof heartRate.value === 'number'
                ? `${heartRate.value.toFixed(1)} ${heartRate.unit || 'BPM'}`
                : 'ç„¡è³‡æ–™';

            const heartConfidence = heartRate && typeof heartRate.confidence === 'number'
                ? `${Math.round((heartRate.confidence > 1 ? heartRate.confidence : heartRate.confidence * 100))}%`
                : 'â€”';

            const respText = respiratoryRate && typeof respiratoryRate.value === 'number'
                ? `${respiratoryRate.value.toFixed(1)} ${respiratoryRate.unit || 'RPM'}`
                : 'ç„¡è³‡æ–™';

            const summaryRows = [
                `<p><strong>å¿ƒç‡:</strong> ${heartRateText} <span class="hr-confidence">${heartConfidence}</span></p>`,
                `<p><strong>å‘¼å¸ç‡:</strong> ${respText}</p>`,
            ];

            if (message) {
                summaryRows.push(`<p><strong>è¨Šæ¯:</strong> ${message}</p>`);
            }

            const resultHtml = `
                <div class="result-item">
                    <h3>å‰ç«¯åˆ†æçµæœ (${displayName})</h3>
                    <p><strong>ç‹€æ…‹:</strong> åˆ†æå®Œæˆ</p>
                    ${summaryRows.join('')}
                    <p><strong>åˆ†ææ™‚é–“:</strong> ${new Date().toLocaleTimeString()}</p>
                </div>
            `;

            webcamResults.innerHTML = resultHtml;
        }

        async function startWebcamRecording() {
            if (currentMode !== MODE_RECORD) {
                return;
            }

            try {
                await ensureWebcamPreview();
            } catch (error) {
                console.error('Failed to initialise webcam preview', error);
                return;
            }

            clearWebcamResults();

            const method = document.getElementById('webcam-method').value;
            const apiKey = persistApiKey(webcamApiInput ? webcamApiInput.value : (document.getElementById('webcam-api-key').value || ''));
            const durationInput = document.getElementById('recording-duration').value;
            const duration = Number.parseInt(durationInput, 10) || 15;

            setRecordingState(true);
            const isFrontendMethod = method.startsWith('js-');

            updateWebcamStatus(`æ­£åœ¨éŒ„å½± ${duration} ç§’ï¼Œè«‹ä¿æŒè‡‰éƒ¨ç©©å®šã€‚`);

            try {
                // ä½¿ç”¨å‰ç«¯ MediaRecorder éŒ„å½±
                const stream = document.getElementById('webcam-preview').srcObject;
                if (!stream) {
                    throw new Error('ç„¡æ³•å–å¾—æ”å½±æ©Ÿä¸²æµ');
                }

                recordedChunks = [];

                // å˜—è©¦ä½¿ç”¨ MP4 æ ¼å¼ï¼Œå¦‚æœä¸æ”¯æ´å‰‡ä½¿ç”¨ WebM
                let mimeType = 'video/mp4';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8,opus';
                }

                mediaRecorder = new MediaRecorder(stream, { mimeType });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    try {
                        // å»ºç«‹å½±ç‰‡ blob
                        const videoBlob = new Blob(recordedChunks, { type: mimeType });

                        if (isFrontendMethod) {
                            await processFrontendRecording(videoBlob, mimeType, method, apiKey);
                        } else {
                            updateWebcamStatus('éŒ„å½±å®Œæˆï¼Œæ­£åœ¨ä¸Šå‚³ä¸¦è™•ç†...');

                            // ä¸Šå‚³ä¸¦è™•ç†å½±ç‰‡
                            const formData = new FormData();
                            const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';
                            formData.append('video', videoBlob, `webcam-recording${extension}`);
                            formData.append('method', method);
                            formData.append('api_key', apiKey);

                            const response = await fetch('/api/process-video', {
                                method: 'POST',
                                body: formData,
                            });

                            const result = await response.json();

                            if (!response.ok) {
                                throw new Error(result.detail || 'å½±ç‰‡è™•ç†å¤±æ•—');
                            }

                            // é¡¯ç¤ºçµæœ
                            displayWebcamResults(result);
                            updateWebcamStatus('è™•ç†å®Œæˆï¼');
                        }

                    } catch (error) {
                        console.error('Processing error:', error);
                        updateWebcamStatus(error.message || 'è™•ç†å½±ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤');
                    } finally {
                        setRecordingState(false);
                        recordedChunks = [];
                        mediaRecorder = null;
                    }
                };

                mediaRecorder.start();

                // è¨­å®šéŒ„å½±æ™‚é–“
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                }, duration * 1000);

            } catch (error) {
                console.error('Unable to start webcam recording', error);
                setRecordingState(false);
                updateWebcamStatus(error.message || 'å•Ÿå‹•æ”å½±æ©ŸéŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤');
            }
        }

        async function stopWebcamRecording() {
            try {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    updateWebcamStatus('æ­£åœ¨åœæ­¢éŒ„å½±...');
                } else {
                    updateWebcamStatus('æ²’æœ‰é€²è¡Œä¸­çš„éŒ„å½±');
                    setRecordingState(false);
                }
            } catch (error) {
                console.error('Unable to stop webcam recording', error);
                updateWebcamStatus(error.message || 'åœæ­¢æ”å½±æ©ŸéŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤');
                setRecordingState(false);
            }
        }

        async function checkRecordingStatus() {
            if (currentMode !== MODE_RECORD) {
                return;
            }

            try {
                const response = await fetch('/api/webcam/status');
                if (!response.ok) {
                    throw new Error('ç‹€æ…‹æŸ¥è©¢å¤±æ•—');
                }

                const payload = await response.json();

                if (payload.message) {
                    updateWebcamStatus(payload.message);
                }

                if (payload.state === 'recording') {
                    setRecordingState(true);
                    return;
                }

                if (payload.state === 'completed') {
                    clearStatusPolling();
                    setRecordingState(false);
                    await resumeWebcamPreview();

                    if (payload.result_text) {
                        webcamResult.textContent = payload.result_text;
                    }

                    if (payload.plot_image) {
                        webcamPlot.src = `data:image/png;base64,${payload.plot_image}`;
                        webcamPlot.style.display = 'block';
                    } else {
                        webcamPlot.style.display = 'none';
                    }
                    return;
                }

                if (payload.state === 'idle') {
                    setRecordingState(false);
                    await resumeWebcamPreview();
                }
            } catch (error) {
                console.error('æŸ¥è©¢æ”å½±æ©ŸéŒ„å½±ç‹€æ…‹æ™‚ç™¼ç”ŸéŒ¯èª¤', error);
            }
        }

        function setupWebcamInteractions() {
            if (startRecordingBtn) {
                startRecordingBtn.addEventListener('click', async (event) => {
                    event.preventDefault();
                    await setAnalysisMode(MODE_RECORD);
                    await startWebcamRecording();
                });
            }

            if (stopRecordingBtn) {
                stopRecordingBtn.addEventListener('click', async (event) => {
                    event.preventDefault();
                    await stopWebcamRecording();
                });
            }

            if (startRealtimeBtn) {
                startRealtimeBtn.addEventListener('click', async (event) => {
                    event.preventDefault();
                    await setAnalysisMode(MODE_REALTIME);
                    await handleStartRealtime();
                });
            }

            if (stopRealtimeBtn) {
                stopRealtimeBtn.addEventListener('click', (event) => {
                    event.preventDefault();
                    handleStopRealtime();
                });
            }

            if (modeTabs.length) {
                modeTabs.forEach((tab) => {
                    tab.addEventListener('click', (event) => {
                        event.preventDefault();
                        setAnalysisMode(tab.dataset.modeTab).catch((error) => console.error(error));
                    });
                });
            }

            const showDetectionInfo = () => {
                if (faceDetectionInfo && currentMode === MODE_REALTIME) {
                    faceDetectionInfo.classList.remove('hidden');
                }
            };

            webcamPreview.addEventListener('loadedmetadata', showDetectionInfo);
            webcamPreview.addEventListener('play', showDetectionInfo);

            const tryInitialisePreview = () => {
                if (currentMode === MODE_UPLOAD) {
                    return;
                }

                if (!mediaStream) {
                    ensureWebcamPreview().catch((error) => {
                        console.warn('ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿé è¦½:', error);
                        updateWebcamStatus('é»æ“Šæ”å½±æ©Ÿç•«é¢ä»¥å•Ÿå‹•é è¦½ï¼ˆéœ€è¦æˆäºˆæ”å½±æ©Ÿæ¬Šé™ï¼‰');
                    });
                }
            };

            setTimeout(tryInitialisePreview, 500);

            webcamPreview.addEventListener('click', tryInitialisePreview);
            webcamPreview.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    tryInitialisePreview();
                }
            });

            const fileMethodSelect = document.getElementById('file-method');

            if (fileMethodSelect) {
                fileMethodSelect.addEventListener('change', updateFileApiKeyVisibility);
            }

            if (webcamMethodSelect) {
                webcamMethodSelect.addEventListener('change', () => {
                    updateApiKeyVisibility();
                });
            }

            if (realtimeMethodSelect) {
                realtimeMethodSelect.addEventListener('change', () => {
                    if (isRealtimeActive) {
                        handleStopRealtime();
                    }
                    updateApiKeyVisibility();
                });
            }

            setRealtimeControlsState(false);
            updateFileApiKeyVisibility();
            updateApiKeyVisibility();
            setAnalysisMode(MODE_UPLOAD).catch((error) => console.error(error));
        }

        function connectStatusSocket() {
            // WebSocket åŠŸèƒ½å·²ç§»é™¤ï¼Œä½¿ç”¨è¼ªè©¢ä»£æ›¿
            console.log('ç‹€æ…‹æ›´æ–°æ”¹ç”¨è¼ªè©¢æ©Ÿåˆ¶');
        }

        window.addEventListener('beforeunload', () => {
            clearStatusPolling();
            releaseWebcamPreview();
            // stopHeartRateSimulation(); // å·²è¨»è§£ï¼šå‡çš„å¿ƒç‡æ¨¡æ“¬åŠŸèƒ½
        });

        // æ¸…é™¤æª”æ¡ˆé¸æ“‡
        function clearFileSelection() {
            selectedFile = null;
            videoInput.value = '';
            filePreview.style.display = 'none';
            uploadProgress.style.display = 'none';
        }

        // æª”æ¡ˆä¸Šå‚³è™•ç†
        fileForm.addEventListener('submit', async (event) => {
            event.preventDefault();

            if (!selectedFile && !videoInput.files[0]) {
                alert('è«‹å…ˆé¸æ“‡ä¸€å€‹å½±ç‰‡æª”æ¡ˆ');
                return;
            }

            const fileToUpload = selectedFile || videoInput.files[0];
            const formData = new FormData();
            formData.append('video', fileToUpload);
            formData.append('method', document.getElementById('file-method').value);
            formData.append('api_key', document.getElementById('file-api-key').value || '');

            showUploadProgress();
            fileStatus.textContent = 'æ­£åœ¨ä¸Šå‚³å½±ç‰‡...';
            if (fileResults) fileResults.innerHTML = '';

            try {
                const response = await uploadWithProgress('/api/process-video', formData);
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.detail || 'è™•ç†å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
                }

                fileStatus.textContent = data.status || 'è™•ç†å®Œæˆï¼';

                // è™•ç†æ–°çš„çµæœæ ¼å¼
                if (fileResults && data.results && data.results.length > 0) {
                    let resultsHtml = '';
                    data.results.forEach(result => {
                        resultsHtml += formatResultItem(result);
                    });
                    fileResults.innerHTML = resultsHtml;
                } else {
                    fileResults.innerHTML = '<p>æ²’æœ‰æª¢æ¸¬åˆ°çµæœ</p>';
                }

                setTimeout(() => {
                    uploadProgress.style.display = 'none';
                }, 2000);

            } catch (error) {
                fileStatus.textContent = error.message || 'è™•ç†æ™‚ç™¼ç”ŸéŒ¯èª¤';
                uploadProgress.style.display = 'none';
            } finally {
                clearInterval(uploadProgressTimer);
            }
        });

        function showUploadProgress() {
            uploadProgress.style.display = 'block';
            const progressFill = uploadProgress.querySelector('.progress-fill');
            const progressPercentage = uploadProgress.querySelector('.progress-percentage');

            let progress = 0;
            clearInterval(uploadProgressTimer);
            uploadProgressTimer = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 90) {
                    progress = 90;
                    clearInterval(uploadProgressTimer);
                }
                progressFill.style.width = progress + '%';
                progressPercentage.textContent = Math.round(progress) + '%';
            }, 500);
        }

        async function uploadWithProgress(url, formData) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();

                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = (e.loaded / e.total) * 100;
                        const progressFill = uploadProgress.querySelector('.progress-fill');
                        const progressPercentage = uploadProgress.querySelector('.progress-percentage');
                        progressFill.style.width = percentComplete + '%';
                        progressPercentage.textContent = Math.round(percentComplete) + '%';

                        if (percentComplete >= 100) {
                            fileStatus.textContent = 'ä¸Šå‚³å®Œæˆï¼Œæ­£åœ¨åˆ†æ...';
                            clearInterval(uploadProgressTimer);
                            progressFill.style.width = '100%';
                            progressPercentage.textContent = '100%';
                        }
                    }
                });

                xhr.addEventListener('load', () => {
                    clearInterval(uploadProgressTimer);
                    const progressFill = uploadProgress.querySelector('.progress-fill');
                    const progressPercentage = uploadProgress.querySelector('.progress-percentage');
                    progressFill.style.width = '100%';
                    progressPercentage.textContent = '100%';
                    resolve({
                        ok: xhr.status >= 200 && xhr.status < 300,
                        status: xhr.status,
                        json: () => Promise.resolve(JSON.parse(xhr.responseText))
                    });
                });

                xhr.addEventListener('error', () => {
                    clearInterval(uploadProgressTimer);
                    reject(new Error('ä¸Šå‚³å¤±æ•—'));
                });

                xhr.open('POST', url);
                xhr.send(formData);
            });
        }

        // åˆå§‹åŒ–
        initializeDragAndDrop();
        setupWebcamInteractions();
        connectStatusSocket();
    </script>
</body>
</html>
