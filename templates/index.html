<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{{ title }}</title>
    <link rel="stylesheet" href="/static/style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ©º</text></svg>">
</head>
<body>
    <header class="hero">
        <h1>ğŸ©º {{ title }}</h1>
        <p>æ”¯æ´å½±ç‰‡ä¸Šå‚³èˆ‡ç¶²è·¯æ”å½±æ©Ÿåˆ†æï¼Œåˆ©ç”¨ VitalLens API ä¼°ç®—å¿ƒç‡ã€å‘¼å¸ç‡èˆ‡ç›¸é—œæ³¢å½¢ã€‚</p>
        <p class="api-status">{{ api_key_status }}</p>
    </header>

    <main class="container">
        <section class="panel" id="video-upload">
            <h2>ğŸ“ å½±ç‰‡æª”æ¡ˆåˆ†æ</h2>
            <form id="file-form" enctype="multipart/form-data">

                <!-- é€²éšæ‹–æ‹½ä¸Šå‚³å€åŸŸ -->
                <div id="drop-zone" class="drop-zone enhanced">
                    <div class="drop-zone-content">
                        <div class="drop-icon">ğŸ¬</div>
                        <p class="drop-text">æ‹–æ‹½å½±ç‰‡æª”æ¡ˆåˆ°æ­¤è™•</p>
                        <p class="drop-subtext">æˆ–é»æ“Šé¸æ“‡æª”æ¡ˆ</p>
                        <div class="upload-button-container">
                            <button type="button" class="drop-button" onclick="document.getElementById('video-input').click()">
                                <span class="button-icon">ğŸ“</span> é¸æ“‡æª”æ¡ˆ
                            </button>
                        </div>
                        <p class="drop-hint">æ”¯æ´ MP4, AVI, MOV, MKV, WebM æ ¼å¼ï¼Œæœ€å¤§ 100MB</p>
                        <div class="format-icons">
                            <span class="format-tag">MP4</span>
                            <span class="format-tag">AVI</span>
                            <span class="format-tag">MOV</span>
                            <span class="format-tag">WebM</span>
                        </div>
                    </div>
                    <div id="file-preview" class="file-preview" style="display: none;">
                        <div class="file-info">
                            <div class="file-thumbnail">ğŸ¥</div>
                            <div class="file-details">
                                <span class="file-name"></span>
                                <span class="file-size"></span>
                                <div class="file-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: 0%"></div>
                                    </div>
                                    <span class="progress-text">æº–å‚™ä¸­...</span>
                                </div>
                            </div>
                            <button type="button" class="remove-file" onclick="clearFileSelection()">
                                <span>âœ•</span>
                            </button>
                        </div>
                    </div>
                    <div id="upload-progress" class="upload-progress" style="display: none;">
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-fill"></div>
                            </div>
                            <span class="progress-percentage">0%</span>
                        </div>
                    </div>
                </div>

                <input id="video-input" name="video" type="file" accept="video/*" required style="display: none;">

                <label for="file-method">é¸æ“‡æª¢æ¸¬æ–¹æ³•</label>
                <select id="file-method" name="method" required>
                    {% for option in methods %}
                    <option value="{{ option }}" {% if option == default_method %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>


                <label for="file-api-key">API Keyï¼ˆä½¿ç”¨ VITALLENS æ™‚å¿…å¡«ï¼‰</label>
                <input id="file-api-key" name="api_key" type="password" placeholder="è«‹è¼¸å…¥ VitalLens API Key">

                <button type="submit">ğŸ” é–‹å§‹åˆ†æ</button>
            </form>
            <div class="status" id="file-status">ç­‰å¾…ä¸Šå‚³å½±ç‰‡...</div>
            <div id="file-results" class="results-grid" aria-live="polite"></div>
            <img id="file-plot" class="plot" alt="å½±ç‰‡åˆ†æåœ–è¡¨" style="display: none;">
        </section>

        <section class="panel" id="webcam-analysis">
            <h2>ğŸ“¹ ç¶²è·¯æ”å½±æ©Ÿåˆ†æ</h2>
            <form id="webcam-form">
                <label for="webcam-method">é¸æ“‡æª¢æ¸¬æ–¹æ³•</label>
                <select id="webcam-method" name="method" required>
                    {% for option in methods %}
                    <option value="{{ option }}" {% if option == default_method %}selected{% endif %}>{{ option }}</option>
                    {% endfor %}
                </select>

                <label for="webcam-api-key">API Keyï¼ˆä½¿ç”¨ VITALLENS æ™‚å¿…å¡«ï¼‰</label>
                <input id="webcam-api-key" name="api_key" type="password" placeholder="è«‹è¼¸å…¥ VitalLens API Key">

                <label for="recording-duration">éŒ„å½±æ™‚é–“ï¼ˆç§’ï¼‰</label>
                <input id="recording-duration" name="duration" type="number" min="5" max="60" value="15" step="5">

                <div class="button-row">
                    <button type="button" id="start-recording">ğŸ”´ é–‹å§‹éŒ„å½±</button>
                    <button type="button" id="stop-recording" class="secondary" disabled>â¹ï¸ åœæ­¢éŒ„å½±</button>
                </div>
            </form>
            <div class="status" id="webcam-status">æº–å‚™é–‹å§‹éŒ„å½±...</div>
            <div id="webcam-results" class="results-grid" aria-live="polite"></div>
            <div class="video-container">
                <video id="webcam-preview" class="webcam-preview" autoplay muted playsinline></video>
                <canvas id="face-overlay" class="face-overlay"></canvas>
                <div class="face-detection-info" id="face-detection-info" style="display: none;">
                    <div class="detection-indicator">
                        <span class="indicator-light"></span>
                        <span class="indicator-text">åµæ¸¬åˆ°äººè‡‰</span>
                    </div>
                    <!-- <div class="heart-rate-preview" id="heart-rate-preview">
                        <span class="hr-label">é ä¼°å¿ƒç‡:</span>
                        <span class="hr-value" id="hr-value">-- BPM</span>
                    </div> -->
                </div>
            </div>
            <img id="webcam-plot" class="plot" alt="ç¶²è·¯æ”å½±æ©Ÿåˆ†æåœ–è¡¨" style="display: none;">
            <pre id="webcam-result" class="result"></pre>
        </section>

        <section class="panel info">
            <h2>ğŸ“‹ ä½¿ç”¨èªªæ˜</h2>
            <h3>å½±ç‰‡æª”æ¡ˆåˆ†æ</h3>
            <ol>
                <li>ä¸Šå‚³å½±ç‰‡ï¼ˆå»ºè­° 5-30 ç§’ï¼Œç¢ºä¿è‡‰éƒ¨æ¸…æ™°å¯è¦‹ï¼‰ã€‚</li>
                <li>ä¾éœ€æ±‚é¸æ“‡æª¢æ¸¬æ–¹æ³•ã€‚VITALLENS éœ€è¦æœ‰æ•ˆ API Keyã€‚</li>
                <li>é»æ“Šã€Œé–‹å§‹åˆ†æã€ï¼Œç­‰å¾…çµæœèˆ‡åœ–è¡¨ã€‚</li>
            </ol>
            <h3>ç¶²è·¯æ”å½±æ©Ÿåˆ†æ</h3>
            <ol>
                <li>æˆæ¬Šç€è¦½å™¨å­˜å–æ”å½±æ©Ÿï¼Œç•«é¢æœƒé¡¯ç¤ºæ–¼é è¦½å€ã€‚</li>
                <li>è¨­å®šéŒ„å½±æ™‚é–“ï¼ˆ5-60 ç§’ï¼‰ä¸¦ä¿æŒé¢å‘æ”å½±æ©Ÿã€‚</li>
                <li>éŒ„å½±å®Œæˆå¾Œç³»çµ±æœƒè‡ªå‹•ä¸Šå‚³ä¸¦åˆ†æï¼Œçµæœå°‡å‡ºç¾åœ¨ä¸‹æ–¹ã€‚</li>
            </ol>
            <p>âš ï¸ æœ¬å·¥å…·åƒ…ä¾›å¥åº·åƒè€ƒï¼Œè‹¥æœ‰å¥åº·ç–‘æ…®è«‹è«®è©¢å°ˆæ¥­é†«å¸«ã€‚</p>
        </section>
    </main>

    <footer>
        <small>Â© {{ title }} | æ”¯æ´å…è²»èˆ‡ VITALLENS API æ–¹æ³•</small>
    </footer>

    <script>
        // DOM å…ƒç´ 
        const fileForm = document.getElementById('file-form');
        const fileStatus = document.getElementById('file-status');
        const fileResults = document.getElementById('file-results');
        const dropZone = document.getElementById('drop-zone');
        const videoInput = document.getElementById('video-input');
        const filePreview = document.getElementById('file-preview');
        const uploadProgress = document.getElementById('upload-progress');

        const webcamForm = document.getElementById('webcam-form');
        const startRecordingBtn = document.getElementById('start-recording');
        const stopRecordingBtn = document.getElementById('stop-recording');
        const webcamStatus = document.getElementById('webcam-status');
        const webcamResults = document.getElementById('webcam-results');
        const webcamPreview = document.getElementById('webcam-preview');
        const faceOverlay = document.getElementById('face-overlay');
        const faceDetectionInfo = document.getElementById('face-detection-info');
        const hrValue = document.getElementById('hr-value');

        let mediaStream = null;
        let selectedFile = null;
        let dragCounter = 0;
        let faceOverlayAnimation = null;
        let heartRateSimulation = null;
        let statusPoller = null;
        let statusSocket = null;
        let isDetectingFace = false;
        let isRecordingActive = false;
        let mediaRecorder = null;
        let recordedChunks = [];

        // åˆå§‹åŒ–æ‹–æ‹½ä¸Šå‚³åŠŸèƒ½
        function initializeDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            dropZone.addEventListener('drop', handleDrop, false);
            videoInput.addEventListener('change', handleFileSelect, false);

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function highlight(e) {
                if (e.type === 'dragenter') {
                    dragCounter++;
                }
                dropZone.classList.add('drag-over');
            }

            function unhighlight(e) {
                if (e.type === 'dragleave') {
                    dragCounter--;
                    if (dragCounter === 0) {
                        dropZone.classList.remove('drag-over');
                    }
                } else if (e.type === 'drop') {
                    dragCounter = 0;
                    dropZone.classList.remove('drag-over');
                }
            }

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFiles(files);
            }

            function handleFileSelect(e) {
                const files = e.target.files;
                handleFiles(files);
            }

            function handleFiles(files) {
                if (files.length > 0) {
                    const file = files[0];
                    if (validateFile(file)) {
                        selectedFile = file;
                        showFilePreview(file);
                    }
                }
            }

            function validateFile(file) {
                const allowedTypes = ['video/mp4', 'video/avi', 'video/mov', 'video/quicktime', 'video/mkv', 'video/webm'];
                if (!allowedTypes.includes(file.type) && !file.name.match(/\.(mp4|avi|mov|mkv|webm)$/i)) {
                    alert('ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼ã€‚è«‹é¸æ“‡ MP4, AVI, MOV, MKV æˆ– WebM æ ¼å¼çš„å½±ç‰‡ã€‚');
                    return false;
                }

                const maxSize = 100 * 1024 * 1024;
                if (file.size > maxSize) {
                    alert('æª”æ¡ˆéå¤§ã€‚è«‹é¸æ“‡å°æ–¼ 100MB çš„å½±ç‰‡æª”æ¡ˆã€‚');
                    return false;
                }

                return true;
            }

            function showFilePreview(file) {
                const fileName = filePreview.querySelector('.file-name');
                const fileSize = filePreview.querySelector('.file-size');
                const progressText = filePreview.querySelector('.progress-text');
                const progressFill = filePreview.querySelector('.progress-fill');

                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                progressText.textContent = 'æº–å‚™ä¸­...';
                progressFill.style.width = '0%';

                filePreview.style.display = 'block';

                let progress = 0;
                const interval = setInterval(() => {
                    progress += Math.random() * 30;
                    if (progress >= 100) {
                        progress = 100;
                        progressText.textContent = 'æº–å‚™å®Œæˆ';
                        clearInterval(interval);
                    } else {
                        progressText.textContent = `æª¢æŸ¥ä¸­... ${Math.round(progress)}%`;
                    }
                    progressFill.style.width = progress + '%';
                }, 200);
            }

            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        function updateWebcamStatus(message) {
            if (webcamStatus) {
                webcamStatus.textContent = message;
            }
        }

        function clearWebcamResults() {
            if (webcamResult) {
                webcamResult.textContent = '';
            }
            if (webcamPlot) {
                webcamPlot.style.display = 'none';
                webcamPlot.removeAttribute('src');
            }
        }

        async function ensureWebcamPreview() {
            if (mediaStream || isRecordingActive) {
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateWebcamStatus('ç€è¦½å™¨ä¸æ”¯æ´æ”å½±æ©ŸåŠŸèƒ½ï¼Œè«‹ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„ Chromeã€Edge æˆ– Firefoxã€‚');
                throw new Error('MediaDevices API not available');
            }

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: false
                });
                webcamPreview.srcObject = mediaStream;
                await webcamPreview.play();
                adjustOverlaySize();
                startFaceDetectionPreview();
                updateWebcamStatus('æ”å½±æ©Ÿå·²å•Ÿå‹•ï¼Œè«‹ä¿æŒè‡‰éƒ¨åœ¨ç•«é¢ä¸­å¤®ã€‚');
            } catch (error) {
                mediaStream = null;
                updateWebcamStatus('ç„¡æ³•å­˜å–æ”å½±æ©Ÿï¼Œè«‹ç¢ºèªè£ç½®å¯ç”¨ä¸¦æˆäºˆæ¬Šé™ã€‚');
                throw error;
            }
        }

        function releaseWebcamPreview() {
            stopFaceDetectionPreview();
            if (faceDetectionInfo) {
                faceDetectionInfo.style.display = 'none';
            }
            if (webcamPreview) {
                webcamPreview.pause();
                webcamPreview.srcObject = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach((track) => track.stop());
                mediaStream = null;
            }
        }

        async function resumeWebcamPreview() {
            if (!mediaStream && !isRecordingActive) {
                try {
                    await ensureWebcamPreview();
                } catch (error) {
                    console.warn('Unable to resume webcam preview', error);
                }
            }
        }

        function adjustOverlaySize() {
            if (!faceOverlay || !webcamPreview) return;

            const width = webcamPreview.videoWidth || webcamPreview.clientWidth || 640;
            const height = webcamPreview.videoHeight || webcamPreview.clientHeight || 480;

            if (width && height) {
                faceOverlay.width = width;
                faceOverlay.height = height;
            }
        }

        function startFaceDetectionPreview() {
            if (!faceOverlay || faceOverlayAnimation) {
                return;
            }

            const ctx = faceOverlay.getContext('2d');
            if (!ctx) {
                return;
            }
            faceDetectionInfo.style.display = 'flex';
            isDetectingFace = true;

            const draw = () => {
                adjustOverlaySize();

                const width = faceOverlay.width;
                const height = faceOverlay.height;

                ctx.clearRect(0, 0, width, height);

                if (!width || !height) {
                    faceOverlayAnimation = requestAnimationFrame(draw);
                    return;
                }

                const boxWidth = width * 0.45;
                const boxHeight = height * 0.6;
                const startX = (width - boxWidth) / 2;
                const startY = (height - boxHeight) / 2;

                ctx.lineWidth = 3;
                ctx.strokeStyle = 'rgba(16, 185, 129, 0.85)';
                ctx.strokeRect(startX, startY, boxWidth, boxHeight);

                ctx.strokeStyle = 'rgba(16, 185, 129, 0.7)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(startX + boxWidth * 0.35, startY + boxHeight * 0.35, boxWidth * 0.05, 0, Math.PI * 2);
                ctx.arc(startX + boxWidth * 0.65, startY + boxHeight * 0.35, boxWidth * 0.05, 0, Math.PI * 2);
                ctx.stroke();

                ctx.beginPath();
                const mouthY = startY + boxHeight * 0.72;
                const mouthCurve = boxWidth * 0.05 * Math.sin(Date.now() / 450);
                ctx.moveTo(startX + boxWidth * 0.3, mouthY);
                ctx.quadraticCurveTo(
                    startX + boxWidth * 0.5,
                    mouthY + mouthCurve,
                    startX + boxWidth * 0.7,
                    mouthY
                );
                ctx.stroke();

                faceOverlayAnimation = requestAnimationFrame(draw);
            };

            draw();
        }

        function stopFaceDetectionPreview() {
            if (faceOverlayAnimation) {
                cancelAnimationFrame(faceOverlayAnimation);
                faceOverlayAnimation = null;
            }
            if (!faceOverlay) {
                return;
            }
            const ctx = faceOverlay.getContext('2d');
            if (ctx) {
                ctx.clearRect(0, 0, faceOverlay.width, faceOverlay.height);
            }
            faceDetectionInfo.style.display = 'none';
            isDetectingFace = false;
        }

        // å·²è¨»è§£ï¼šå‡çš„å¿ƒç‡æ¨¡æ“¬åŠŸèƒ½
        // function startHeartRateSimulation() {
        //     if (heartRateSimulation) {
        //         return;
        //     }

        //     let bpm = 78 + Math.random() * 6;
        //     heartRateSimulation = setInterval(() => {
        //         bpm += (Math.random() - 0.5) * 4;
        //         bpm = Math.max(55, Math.min(110, bpm));
        //         hrValue.textContent = `${Math.round(bpm)} BPM`;
        //     }, 1500);
        // }

        // function stopHeartRateSimulation() {
        //     if (heartRateSimulation) {
        //         clearInterval(heartRateSimulation);
        //         heartRateSimulation = null;
        //     }
        //     hrValue.textContent = '-- BPM';
        // }

        function setRecordingState(isRecording) {
            isRecordingActive = isRecording;
            startRecordingBtn.disabled = isRecording;
            stopRecordingBtn.disabled = !isRecording;

            // å·²è¨»è§£ï¼šå‡çš„å¿ƒç‡æ¨¡æ“¬åŠŸèƒ½
            // if (isRecording) {
            //     startHeartRateSimulation();
            // } else {
            //     stopHeartRateSimulation();
            // }
        }

        function scheduleStatusPolling() {
            clearStatusPolling();
            checkRecordingStatus();
            statusPoller = setInterval(checkRecordingStatus, 2000);
        }

        function clearStatusPolling() {
            if (statusPoller) {
                clearInterval(statusPoller);
                statusPoller = null;
            }
        }

        function clearWebcamResults() {
            if (webcamResults) {
                webcamResults.innerHTML = '';
            }
        }

        function displayWebcamResults(data) {
            if (!webcamResults) return;

            if (data.results && data.results.length > 0) {
                let resultsHtml = '';
                data.results.forEach(result => {
                    resultsHtml += `
                        <div class="result-item">
                            <h3>${result.display_name || 'Webcam Recording'}</h3>
                            <p><strong>ç‹€æ…‹:</strong> ${result.status}</p>
                            ${result.summary ? `<p><strong>æ‘˜è¦:</strong> ${result.summary}</p>` : ''}
                            ${result.result_text ? `<pre class="result-text">${result.result_text}</pre>` : ''}
                            ${result.plot_image ? `<img src="data:image/png;base64,${result.plot_image}" class="plot" alt="åˆ†æåœ–è¡¨">` : ''}
                        </div>
                    `;
                });
                webcamResults.innerHTML = resultsHtml;
            } else {
                webcamResults.innerHTML = '<p>æ²’æœ‰æª¢æ¸¬åˆ°çµæœ</p>';
            }
        }

        async function startWebcamRecording() {
            try {
                await ensureWebcamPreview();
            } catch (error) {
                console.error('Failed to initialise webcam preview', error);
                return;
            }

            clearWebcamResults();

            const method = document.getElementById('webcam-method').value;
            const apiKey = document.getElementById('webcam-api-key').value || '';
            const durationInput = document.getElementById('recording-duration').value;
            const duration = Number.parseInt(durationInput, 10) || 15;

            setRecordingState(true);
            updateWebcamStatus(`æ­£åœ¨éŒ„å½± ${duration} ç§’ï¼Œè«‹ä¿æŒè‡‰éƒ¨ç©©å®šã€‚`);

            try {
                // ä½¿ç”¨å‰ç«¯ MediaRecorder éŒ„å½±
                const stream = document.getElementById('webcam-preview').srcObject;
                if (!stream) {
                    throw new Error('ç„¡æ³•å–å¾—æ”å½±æ©Ÿä¸²æµ');
                }

                recordedChunks = [];

                // å˜—è©¦ä½¿ç”¨ MP4 æ ¼å¼ï¼Œå¦‚æœä¸æ”¯æ´å‰‡ä½¿ç”¨ WebM
                let mimeType = 'video/mp4';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8,opus';
                }

                mediaRecorder = new MediaRecorder(stream, { mimeType });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    try {
                        // å»ºç«‹å½±ç‰‡ blob
                        const videoBlob = new Blob(recordedChunks, { type: mimeType });

                        updateWebcamStatus('éŒ„å½±å®Œæˆï¼Œæ­£åœ¨ä¸Šå‚³ä¸¦è™•ç†...');

                        // ä¸Šå‚³ä¸¦è™•ç†å½±ç‰‡
                        const formData = new FormData();
                        const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';
                        formData.append('video', videoBlob, `webcam-recording${extension}`);
                        formData.append('method', method);
                        formData.append('api_key', apiKey);

                        const response = await fetch('/api/process-video', {
                            method: 'POST',
                            body: formData,
                        });

                        const result = await response.json();

                        if (!response.ok) {
                            throw new Error(result.detail || 'å½±ç‰‡è™•ç†å¤±æ•—');
                        }

                        // é¡¯ç¤ºçµæœ
                        displayWebcamResults(result);
                        updateWebcamStatus('è™•ç†å®Œæˆï¼');

                    } catch (error) {
                        console.error('Processing error:', error);
                        updateWebcamStatus(error.message || 'è™•ç†å½±ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤');
                    } finally {
                        setRecordingState(false);
                        recordedChunks = [];
                        mediaRecorder = null;
                    }
                };

                mediaRecorder.start();

                // è¨­å®šéŒ„å½±æ™‚é–“
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                }, duration * 1000);

            } catch (error) {
                console.error('Unable to start webcam recording', error);
                setRecordingState(false);
                updateWebcamStatus(error.message || 'å•Ÿå‹•æ”å½±æ©ŸéŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤');
            }
        }

        async function stopWebcamRecording() {
            try {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    updateWebcamStatus('æ­£åœ¨åœæ­¢éŒ„å½±...');
                } else {
                    updateWebcamStatus('æ²’æœ‰é€²è¡Œä¸­çš„éŒ„å½±');
                    setRecordingState(false);
                }
            } catch (error) {
                console.error('Unable to stop webcam recording', error);
                updateWebcamStatus(error.message || 'åœæ­¢æ”å½±æ©ŸéŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤');
                setRecordingState(false);
            }
        }

        async function checkRecordingStatus() {
            try {
                const response = await fetch('/api/webcam/status');
                if (!response.ok) {
                    throw new Error('ç‹€æ…‹æŸ¥è©¢å¤±æ•—');
                }

                const payload = await response.json();

                if (payload.message) {
                    updateWebcamStatus(payload.message);
                }

                if (payload.state === 'recording') {
                    setRecordingState(true);
                    return;
                }

                if (payload.state === 'completed') {
                    clearStatusPolling();
                    setRecordingState(false);
                    await resumeWebcamPreview();

                    if (payload.result_text) {
                        webcamResult.textContent = payload.result_text;
                    }

                    if (payload.plot_image) {
                        webcamPlot.src = `data:image/png;base64,${payload.plot_image}`;
                        webcamPlot.style.display = 'block';
                    } else {
                        webcamPlot.style.display = 'none';
                    }
                    return;
                }

                if (payload.state === 'idle') {
                    setRecordingState(false);
                    await resumeWebcamPreview();
                }
            } catch (error) {
                console.error('æŸ¥è©¢æ”å½±æ©ŸéŒ„å½±ç‹€æ…‹æ™‚ç™¼ç”ŸéŒ¯èª¤', error);
            }
        }

        function setupWebcamInteractions() {
            if (!startRecordingBtn || !stopRecordingBtn) {
                return;
            }

            startRecordingBtn.addEventListener('click', async (event) => {
                event.preventDefault();
                await startWebcamRecording();
            });

            stopRecordingBtn.addEventListener('click', async (event) => {
                event.preventDefault();
                await stopWebcamRecording();
            });

            webcamPreview.addEventListener('loadedmetadata', () => {
                adjustOverlaySize();
                startFaceDetectionPreview();
            });

            webcamPreview.addEventListener('play', () => {
                adjustOverlaySize();
                startFaceDetectionPreview();
            });

            window.addEventListener('resize', adjustOverlaySize);

            const tryInitialisePreview = () => {
                if (!mediaStream) {
                    ensureWebcamPreview().catch((error) => {
                        console.warn('ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿé è¦½:', error);
                        updateWebcamStatus('é»æ“Šæ”å½±æ©Ÿç•«é¢ä»¥å•Ÿå‹•é è¦½ï¼ˆéœ€è¦æˆäºˆæ”å½±æ©Ÿæ¬Šé™ï¼‰');
                    });
                }
            };

            // è‡ªå‹•å•Ÿå‹•æ”å½±æ©Ÿé è¦½
            setTimeout(tryInitialisePreview, 500);

            webcamPreview.addEventListener('click', tryInitialisePreview);
            webcamPreview.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    tryInitialisePreview();
                }
            });
        }

        function connectStatusSocket() {
            // WebSocket åŠŸèƒ½å·²ç§»é™¤ï¼Œä½¿ç”¨è¼ªè©¢ä»£æ›¿
            console.log('ç‹€æ…‹æ›´æ–°æ”¹ç”¨è¼ªè©¢æ©Ÿåˆ¶');
        }

        window.addEventListener('beforeunload', () => {
            clearStatusPolling();
            releaseWebcamPreview();
            // stopHeartRateSimulation(); // å·²è¨»è§£ï¼šå‡çš„å¿ƒç‡æ¨¡æ“¬åŠŸèƒ½
        });

        // æ¸…é™¤æª”æ¡ˆé¸æ“‡
        function clearFileSelection() {
            selectedFile = null;
            videoInput.value = '';
            filePreview.style.display = 'none';
            uploadProgress.style.display = 'none';
        }

        // æª”æ¡ˆä¸Šå‚³è™•ç†
        fileForm.addEventListener('submit', async (event) => {
            event.preventDefault();

            if (!selectedFile && !videoInput.files[0]) {
                alert('è«‹å…ˆé¸æ“‡ä¸€å€‹å½±ç‰‡æª”æ¡ˆ');
                return;
            }

            const fileToUpload = selectedFile || videoInput.files[0];
            const formData = new FormData();
            formData.append('video', fileToUpload);
            formData.append('method', document.getElementById('file-method').value);
            formData.append('api_key', document.getElementById('file-api-key').value || '');

            showUploadProgress();
            fileStatus.textContent = 'æ­£åœ¨ä¸Šå‚³å½±ç‰‡...';
            if (fileResults) fileResults.innerHTML = '';

            try {
                const response = await uploadWithProgress('/api/process-video', formData);
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.detail || 'è™•ç†å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
                }

                fileStatus.textContent = data.status || 'è™•ç†å®Œæˆï¼';

                // è™•ç†æ–°çš„çµæœæ ¼å¼
                if (fileResults && data.results && data.results.length > 0) {
                    let resultsHtml = '';
                    data.results.forEach(result => {
                        resultsHtml += `
                            <div class="result-item">
                                <h3>${result.display_name || result.file_name}</h3>
                                <p><strong>ç‹€æ…‹:</strong> ${result.status}</p>
                                ${result.summary ? `<p><strong>æ‘˜è¦:</strong> ${result.summary}</p>` : ''}
                                ${result.result_text ? `<pre class="result-text">${result.result_text}</pre>` : ''}
                                ${result.plot_image ? `<img src="data:image/png;base64,${result.plot_image}" class="plot" alt="åˆ†æåœ–è¡¨">` : ''}
                            </div>
                        `;
                    });
                    fileResults.innerHTML = resultsHtml;
                } else {
                    fileResults.innerHTML = '<p>æ²’æœ‰æª¢æ¸¬åˆ°çµæœ</p>';
                }

                setTimeout(() => {
                    uploadProgress.style.display = 'none';
                }, 2000);

            } catch (error) {
                fileStatus.textContent = error.message || 'è™•ç†æ™‚ç™¼ç”ŸéŒ¯èª¤';
                uploadProgress.style.display = 'none';
            }
        });

        function showUploadProgress() {
            uploadProgress.style.display = 'block';
            const progressFill = uploadProgress.querySelector('.progress-fill');
            const progressPercentage = uploadProgress.querySelector('.progress-percentage');

            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 90) {
                    progress = 90;
                    clearInterval(interval);
                }
                progressFill.style.width = progress + '%';
                progressPercentage.textContent = Math.round(progress) + '%';
            }, 500);
        }

        async function uploadWithProgress(url, formData) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();

                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = (e.loaded / e.total) * 100;
                        const progressFill = uploadProgress.querySelector('.progress-fill');
                        const progressPercentage = uploadProgress.querySelector('.progress-percentage');
                        progressFill.style.width = percentComplete + '%';
                        progressPercentage.textContent = Math.round(percentComplete) + '%';

                        if (percentComplete >= 100) {
                            fileStatus.textContent = 'ä¸Šå‚³å®Œæˆï¼Œæ­£åœ¨åˆ†æ...';
                        }
                    }
                });

                xhr.addEventListener('load', () => {
                    resolve({
                        ok: xhr.status >= 200 && xhr.status < 300,
                        status: xhr.status,
                        json: () => Promise.resolve(JSON.parse(xhr.responseText))
                    });
                });

                xhr.addEventListener('error', () => {
                    reject(new Error('ä¸Šå‚³å¤±æ•—'));
                });

                xhr.open('POST', url);
                xhr.send(formData);
            });
        }

        // åˆå§‹åŒ–
        initializeDragAndDrop();
        setupWebcamInteractions();
        connectStatusSocket();
    </script>
</body>
</html>
